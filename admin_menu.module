<?php
// $Id$

/**
 * @file
 * Render an administrative menu as a dropdown menu at the top of the window.
 *
 * Note: Most theme-functions in Administration Menu are not invoked via theme(),
 * because we try to keep this module as fast as possible and chances are very
 * small that someone wants to override those functions.
 */

/**
 * Implementation of hook_help().
 */
function admin_menu_help($section) {
  switch ($section) {
    case 'admin/settings/admin_menu':
      return t('The administration menu module provides a dropdown menu arranged for one- or two-click access to most administrative tasks and other common destinations (to users with the proper permissions). Use the settings below to customize the appearance of the menu.');

    case 'admin/help#admin_menu':
      $output = '';
      $output .= '<p>' . t('The administration menu module provides a dropdown menu arranged for one- or two-click access to most administrative tasks and other common destinations (to users with the proper permissions). Administration menu also displays the number of anonymous and authenticated users, and allows modules to add their own custom menu items. Integration with the menu varies from module to module; the contributed module <a href="@drupal">Devel</a>, for instance, makes strong use of the administration menu module to provide quick access to development tools.', array('@drupal' => 'http://drupal.org/project/devel')) . '</p>';
      $output .= '<p>' . t('The administration menu <a href="@settings">settings page</a> allows you to modify some elements of the menu\'s behavior and appearance. Since the appearance of the menu is dependent on your site theme, substantial customizations require modifications to your site\'s theme and CSS files. See the advanced module README.txt file for more information on theme and CSS customizations.', array('@settings' => url('admin/settings/admin_menu'))) . '</p>';
      $output .= '<p>' . t('The menu items displayed in the administration menu depend upon the actual permissions of the viewer. First, the administration menu is only displayed to users in roles with the <em>Access administration menu</em> (admin_menu module) permission. Second, a user must be a member of a role with the <em>Access administration pages</em> (system module) permission to view administrative links. And, third, only currently permitted links are displayed; for example, if a user is not a member of a role with the permissions <em>Administer permissions</em> (user module) and <em>Administer users</em> (user module), the <em>User management</em> menu item is not displayed.') . '</p>';
      return $output;
  }
}

/**
 * Implementation of hook_perm().
 */
function admin_menu_perm() {
  return array('access administration menu', 'display drupal links');
}

/**
 * Implementation of hook_menu().
 *
 * We can't move this into admin_menu_footer(), because PHP-only based themes
 * like chameleon load and output scripts and stylesheets in front of
 * theme_closure(), so we ensure Admin menu's styles and scripts are loaded on
 * all pages via hook_menu().
 */
function admin_menu_menu($may_cache) {
  $items = array();
  if ($may_cache) {
    // AJAX callback.
    $items[] = array(
      'path' => 'js/admin_menu/cache',
      'callback' => 'admin_menu_js_cache',
      'access' => user_access('access administration menu'),
      'type' => MENU_CALLBACK,
    );
    // Module settings.
    $items[] = array(
      'path' => 'admin/settings/admin_menu',
      'title' => t('Administration menu'),
      'description' => t('Adjust administration menu settings.'),
      'callback' => 'drupal_get_form',
      'callback arguments' => array('admin_menu_theme_settings'),
      'access' => user_access('administer site configuration'),
    );
    // Menu link callbacks.
    $items[] = array(
      'path' => 'admin_menu/toggle-modules',
      'callback' => 'admin_menu_toggle_modules',
      'access' => user_access('administer site configuration'),
      'type' => MENU_CALLBACK,
    );
    return;
  }
  if (!user_access('access administration menu') || admin_menu_suppress(FALSE)) {
    return;
  }
  // Performance: Skip this entirely for AJAX requests.
  if (strpos($_GET['q'], 'js/') === 0) {
    return;
  }
  global $user, $locale;

  $path = drupal_get_path('module', 'admin_menu');
  drupal_add_css($path . '/admin_menu.css', 'module', 'all', FALSE);
  // Performance: Defer execution.
  drupal_add_js($path . '/admin_menu.js', 'module', 'header', TRUE);

  // Destination query strings are applied via JS.
  $settings['destination'] = drupal_get_destination();

  // Hash for client-side HTTP/AJAX caching.
  $cid = 'admin_menu:' . $user->uid . ':' . $locale;
  if (!empty($_COOKIE['has_js']) && ($hash = admin_menu_cache_get($cid))) {
    $settings['hash'] = $hash;
    // The base path to use for cache requests depends on whether clean URLs
    // are enabled, whether Drupal runs in a sub-directory, and on the language
    // system configuration. url() already provides us the proper path, but we
    // additionally need to ensure that it ends with a slash.
    $settings['basePath'] = rtrim(url(''), '/') . '/';
  }

  if ($setting = variable_get('admin_menu_margin_top', 1)) {
    $settings['margin_top'] = $setting;
  }
  if ($setting = variable_get('admin_menu_position_fixed', 0)) {
    $settings['position_fixed'] = $setting;
  }
  if ($setting = variable_get('admin_menu_tweak_tabs', 0)) {
    $settings['tweak_tabs'] = $setting;
  }
  if ($_GET['q'] == 'admin/build/menu' && variable_get('admin_menu_tweak_menu', 0)) {
    drupal_add_js($path . '/admin_menu.menu.js');
    drupal_add_js('misc/collapse.js');
  }
  elseif ($_GET['q'] == 'admin/build/modules') {
    $settings['tweak_modules'] = variable_get('admin_menu_tweak_modules', 0);
  }

  drupal_add_js(array('basePath' => base_path()), 'setting');
  drupal_add_js(array('admin_menu' => $settings), 'setting');

  if ($_GET['q'] == 'admin/settings/admin_menu' || $_GET['q'] == 'admin/settings/devel') {
    require_once drupal_get_path('module', 'admin_menu') . '/admin_menu.inc';
  }
  return $items;
}

/**
 * Suppress display of administration menu.
 *
 * This function should be called from within another module's page callback
 * (preferably using module_invoke()) when the menu should not be displayed.
 * This is useful for modules that implement popup pages or other special
 * pages where the menu would be distracting or break the layout.
 *
 * @param $set
 *   Defaults to TRUE. If called before hook_footer, the menu will not be
 *   displayed. If FALSE is passed, the suppression state is returned.
 */
function admin_menu_suppress($set = TRUE) {
  static $suppress = FALSE;
  // drupal_add_js() must only be invoked once.
  if (!empty($set) && $suppress === FALSE) {
    $suppress = TRUE;
    drupal_add_js(array('admin_menu' => array('suppress' => 1)), 'setting');
  }
  return $suppress;
}

/**
 * Implementation of hook_footer().
 */
function admin_menu_footer($main = 0) {
  if (!user_access('access administration menu') || admin_menu_suppress(FALSE)) {
    return;
  }
  global $user, $locale;

  // @todo How does this work in D5? :)
  // Determine whether we need to rebuild.
  $rebuild = variable_get('admin_menu_rebuild_links', FALSE);
  $cid = 'admin_menu:' . $user->uid . ':' . $locale;

  // Do nothing at all here if the client supports client-side caching, no
  // rebuild is needed, the user has a hash, and is NOT requesting the cache
  // update path. Consult the hash cache last, since it requires a DB request.
  // @todo Implement a sanity-check to prevent permanent double requests; i.e.
  //   what if the client-side cache fails for any reason and performs a second
  //   request on every page?
  if (!empty($_COOKIE['has_js']) && !$rebuild && strpos($_GET['q'], 'js/admin_menu/cache') !== 0) {
    if (admin_menu_cache_get($cid)) {
      return;
    }
  }

  // Try to load and output administration menu from server-side cache.
  $cache = cache_get($cid, 'cache_menu');
  if ($cache && isset($cache->data)) {
    $content = $cache->data;
  }

  // Rebuild the output.
  if (!isset($content)) {
    global $_menu;

    // Get item id of /q=admin, which we suppose to be the root for admin menu.
    $mid_admin = $_menu['path index']['admin'];
    $_admin_menu = &admin_menu_get_menu($mid_admin);

    // Allow other modules to integrate with admin_menu (uncached).
    foreach (module_implements('admin_menu') as $module) {
      $function = $module . '_admin_menu';
      $function($_admin_menu, FALSE);
    }

    $content  = '<div id="admin-menu">';
    $content .= theme_admin_menu_tree($mid_admin);
    $content .= '</div>';

    // Cache the menu for this user.
    cache_set($cid, 'cache_menu', $content, time() + (60 * 60 * 24));
  }

  // Store the new hash for this user.
  if (!empty($_COOKIE['has_js'])) {
    admin_menu_cache_set($cid, md5($content));
  }

  return $content;
}

/**
 * Retrieve a client-side cache hash from cache.
 *
 * The hash cache is consulted more than once per request; we therefore cache
 * the results statically to avoid multiple database requests.
 *
 * This should only be used for client-side cache hashes. Use cache_menu for
 * administration menu content.
 *
 * @param $cid
 *   The cache ID of the data to retrieve.
 */
function admin_menu_cache_get($cid) {
  static $cache = array();

  if (!array_key_exists($cid, $cache)) {
    $cache[$cid] = cache_get($cid, 'cache_admin_menu');
    if ($cache[$cid] && isset($cache[$cid]->data)) {
      $cache[$cid] = $cache[$cid]->data;
    }
  }

  return $cache[$cid];
}

/**
 * Store a client-side cache hash in persistent cache.
 *
 * This should only be used for client-side cache hashes. Use cache_menu for
 * administration menu content.
 *
 * @param $cid
 *   The cache ID of the data to retrieve.
 */
function admin_menu_cache_set($cid, $data) {
  cache_set($cid, 'cache_admin_menu', $data);
}

/**
 * Menu callback; Output administration menu for HTTP caching via AJAX request.
 */
function admin_menu_js_cache($hash = NULL) {
  // Fetch the menu.
  $content = admin_menu_footer();

  // @todo According to http://www.mnot.net/blog/2006/05/11/browser_caching,
  //   IE will only cache the content when it is compressed.
  // Determine if the client accepts gzipped data.
  if (isset($_SERVER['HTTP_ACCEPT_ENCODING']) && function_exists('gzencode')) {
    if (strpos($_SERVER['HTTP_ACCEPT_ENCODING'], 'gzip') !== FALSE) {
      $encoding = 'gzip';
    }
    elseif (strpos($_SERVER['HTTP_ACCEPT_ENCODING'], 'x-gzip') !== FALSE) {
      $encoding = 'x-gzip';
    }
    if (!empty($encoding)) {
      header('Vary: Accept-Encoding');
      header('Content-Encoding: ' . $encoding);
      $content = gzencode($content, 9, FORCE_GZIP);
    }
  }

  $expires = time() + (3600 * 24 * 365);
  header('Expires: ' . gmdate('D, d M Y H:i:s', $expires) . ' GMT');
  header('Last-Modified: ' . gmdate('D, d M Y H:i:s') . ' GMT');
  header('Cache-Control: max-age=' . $expires);
  header('Content-Length: ' . strlen($content));

  // Suppress Devel module.
  $GLOBALS['devel_shutdown'] = FALSE;
  echo $content;
  exit;
}

/**
 * Return administration menu from cache or rebuild it.
 *
 * @param $mid_admin
 *   The menu item id to use for the administration menu.
 *
 * @return
 *   An array containing a complete menu structure of all cached administration
 *   menu items.
 */
function &admin_menu_get_menu($mid_admin = 5) {
  static $_admin_menu;

  if (isset($_admin_menu)) {
    return $_admin_menu;
  }
  global $user, $locale;

  $cid = $user->uid . ':' . $locale . ':admin_menu';
  $cache = cache_get($cid, 'cache_menu');
  // Check if cache is an array needed to distinguish between v5.x-1.2 and later
  // versions.
  if ($cache && substr($cache->data, 0, 1) == 'a') {
    $_admin_menu = unserialize($cache->data);
  }
  else {
    require_once drupal_get_path('module', 'admin_menu') . '/admin_menu.inc';
    admin_menu_build($_admin_menu, $mid_admin);
    cache_set($cid, 'cache_menu', serialize($_admin_menu), time() + (60 * 60 * 24));
  }

  return $_admin_menu;
}

/**
 * Return a rendered menu tree.
 *
 * @param $pid
 *   The menu item id to use for the administration menu.
 *
 * @return string
 *   The complete, rendered administration menu.
 */
function theme_admin_menu_tree($pid = 1) {
  $_admin_menu = admin_menu_get_menu();
  $output = '';

  if (!empty($_admin_menu[$pid]['children'])) {
    foreach ($_admin_menu[$pid]['children'] as $mid) {
      $output .= theme_admin_menu_item($mid, theme_admin_menu_tree($mid), empty($_admin_menu[$mid]['children']));
    }
  }
  return $output ? "\n<ul>" . $output . '</ul>' : '';
}

/**
 * High-performance implementation of theme_menu_item().
 *
 * This saves us a theme() call and does only the absolute minimum to get
 * the admin menu links rendered.
 *
 * @param $mid
 *   The menu id of the item.
 * @param $children
 *   A string containing any rendered child items of this menu.
 * @param $leaf
 *   A boolean indicating whether this menu item is a leaf.
 */
function theme_admin_menu_item($mid, $children = '', $leaf = TRUE) {
  static $display_option, $destination;

  $_admin_menu = admin_menu_get_menu();
  $item = $_admin_menu[$mid];

  if (!isset($display_option)) {
    $display_option = variable_get('admin_menu_display', 0);
    $destination = drupal_get_destination();
  }
  // Display extra information about menu items if enabled (devel).
  if ($display_option) {
    if ($display_option == 'mid') {
      $item['title'] = $item['title'] . ' (' . $mid . ')';
    }
    else if (isset($item[$display_option])) {
      $item['title'] = $item['title'] . ' (' . $item[$display_option] . ')';
    }
  }

  $class = array();
  if (!$leaf) {
    $class[] = 'expandable';
  }
  if (isset($item['class'])) {
    $class[] = $item['class'];
  }

  // Strip destination query string from href attribute and apply a CSS class
  // for our JavaScript behavior instead.
  $path = preg_replace('/[\?|&]' . preg_quote($destination, '/') . '/', '', $item['path']);
  if ($path != $item['path']) {
    if (!empty($item['attributes']['class'])) {
      $item['attributes']['class'] .= ' admin-menu-destination';
    }
    else {
      $item['attributes']['class'] = 'admin-menu-destination';
    }
  }

  $output = '<li' . (!empty($class) ? ' class="' . implode(' ', $class) . '"' : '') . '>';
  $output .= '<a href="' . check_url($path) . '"' . drupal_attributes($item['attributes']) . '>' . filter_xss_admin($item['title']) . '</a>' . $children . '</li>';
  return $output;
}

/**
 * Comparator routine for use in sorting menu items.
 */
function _admin_menu_sort($a, $b) {
  $_admin_menu = admin_menu_get_menu();

  $a = $_admin_menu[$a];
  $b = $_admin_menu[$b];

  if ($a['weight'] < $b['weight']) {
    return -1;
  }
  elseif ($a['weight'] > $b['weight']) {
    return 1;
  }
  elseif (isset($a['title']) && isset($b['title'])) {
    return strnatcasecmp($a['title'], $b['title']);
  }
  else {
    return 1;
  }
}

/**
 * Adjust the menu item path.
 *
 * Adjust the path of local tasks and let them point to their parent item.
 * Finally build the url. These functions have been moved here to be able
 * to cache the final results.
 *
 * @param &$item
 *   An admin menu item.
 */
function admin_menu_item_url(&$_admin_menu, $mid) {
  $link_item = $mid;
  while ($_admin_menu[$link_item]['type'] & MENU_LINKS_TO_PARENT) {
    $link_item = $_admin_menu[$link_item]['pid'];
  }

  if (!isset($_admin_menu[$link_item]['processed'])) {
    $_admin_menu[$mid]['path'] = url($_admin_menu[$link_item]['path'], isset($_admin_menu[$mid]['query']) ? $_admin_menu[$mid]['query'] : NULL);
    $_admin_menu[$link_item]['processed'] = TRUE;
  }
  else {
    // Copy the already processed path of the parent item to the
    // default local task.
    $_admin_menu[$mid]['path'] = $_admin_menu[$link_item]['path'];
  }
}

/**
 * Add a custom menu item.
 *
 * @param $_admin_menu
 *   An array containing the complete administration menu structure, passed by
 *   reference.
 * @param $pid
 *   The parent menu item id.
 * @param $item
 *   An menu item array for the menu system. May contain the key 'weight' to
 *   adjust the item's weight.
 *
 * @return
 *   The id of the new menu item.
 */
function admin_menu_add_item(&$_admin_menu, $pid, $item) {
  if (empty($item['path'])) {
    return FALSE;
  }
  $item['pid'] = $pid;
  $item['children'] = array();
  $id = max(array_keys($_admin_menu)) + 1;
  $_admin_menu[$id] = $item;
  $_admin_menu[$pid]['children'][] = $id;
  $_admin_menu['index'][$item['path']] = $id;
  admin_menu_item_url($_admin_menu, $id);

  // Sort items.
  usort($_admin_menu[$pid]['children'], '_admin_menu_sort');

  return $id;
}

/**
 * Implementation of hook_admin_menu().
 *
 * @param array $admin_menu
 *   An array containing the complete administration menu structure, passed by
 *   reference.
 * @param bool $may_cache
 *   Whether changes will be cached. If new menu items contain dynamic
 *   information, such as query strings or user-related data, these should be
 *   added on each page request ($may_cache = FALSE).
 */
function admin_menu_admin_menu(&$admin_menu, $may_cache) {
  if (!$may_cache) {
    // Add count of active anonymous/authenticated users.
    // @see user_block(), user.module
    $interval   = time() - variable_get('user_block_seconds_online', 900);
    $count_anon = sess_count($interval);
    $count_auth = db_result(db_query("SELECT COUNT(DISTINCT uid) FROM {sessions} WHERE uid > 0 AND timestamp >= %d", $interval));

    $mid_admin  = $admin_menu['index']['admin'];
    $title      = t('Current anonymous / authenticated users');
    $icon_users = '<img src="' . base_path() . drupal_get_path('module', 'admin_menu') . '/images/icon_users.png" width="16" height="15" alt="' . $title . '" title="' . $title . '" />';
    admin_menu_add_item($admin_menu, $mid_admin, array(
      'title' => $count_anon . ' / ' . $count_auth . ' ' . $icon_users,
      'path' => user_access('administer users') ? 'admin/user/user' : drupal_get_normal_path(variable_get('site_frontpage', 'node')),
      'weight' => -90,
      'class' => 'admin-menu-action admin-menu-icon admin-menu-users',
    ));
  }
}

/**
 * Implementation of hook_admin_menu() for Devel module (temporary).
 *
 * - Adds most used functions 'empty cache' and 'variable editor' to the menu in
 *   Administration Menu's icon.
 * - Adds links to switch to a different user to the logout button.
 */
if (module_exists('devel') && !function_exists('devel_admin_menu')) {
  function devel_admin_menu(&$admin_menu, $may_cache) {
    $access_devel = user_access('access devel information');
    $access_switch = user_access('switch users');
    if (!$access_devel && !$access_switch) {
      return;
    }

    $mid_icon = $admin_menu['index']['admin_menu_icon'];
    if ($may_cache) {
      // Add variable editor.
      if ($access_devel) {
        admin_menu_add_item($admin_menu, $mid_icon, array('title' => t('Variable editor'), 'path' => 'devel/variable', 'weight' => 20));
      }
    }
    else {
      // Add clear-cache.
      if ($access_devel) {
        admin_menu_add_item($admin_menu, $mid_icon, array('title' => t('Empty cache'), 'path' => 'devel/cache/clear', 'weight' => 20, 'query' => drupal_get_destination()));
      }
      // Add switch_user items.
      if ($access_switch && $devel_user_links = module_invoke('devel', 'switch_user_list')) {
        $mid_user = $admin_menu['index']['user'];
        foreach ($devel_user_links as $link) {
          if (is_array($link)) {
            admin_menu_add_item($admin_menu, $mid_user, array(
              'title' => $link['title'],
              'description' => $link['attributes']['title'],
              'path' => $link['href'],
              'query' => $link['query'],
            ));
          }
          // @todo Remove when Devel 5.x-1.1 has been released.
          elseif (preg_match('!href="' . base_path() . '([^\?]+)\?([^"]+)" title="([^"]+)">((<em>)?[^<]+(</em>)?)!', $link, $match)) {
            admin_menu_add_item($admin_menu, $mid_user, array('title' => $match[4], 'description' => $match[3], 'path' => urldecode($match[1]), 'query' => $match[2]));
          }
        }
      }
    }
  }
}

/**
 * Clear the cached admin menu tree.
 */
function admin_menu_clear_cache() {
  // cache_clear_all() does not support a leading wildcard.
  db_query("DELETE FROM {cache_menu} WHERE cid LIKE '%%:admin_menu%%'");
}

/**
 * Implementation of hook_panels_cache().
 *
 * We're misusing the panels_cache hook here: whenever called, check if the
 * current request has a POST payload, and clear the cached admin menu.
 * This can easily be seen as a hack, as it will happen way too often when
 * working on the panels admin pages.
 */
function admin_menu_panels_cache() {
  if (!empty($_POST)) {
    admin_menu_clear_cache();
  }
}

/**
 * Menu callback; Enable/disable developer modules.
 */
function admin_menu_toggle_modules() {
  require_once drupal_get_path('module', 'admin_menu') . '/admin_menu.inc';
  _admin_menu_toggle_modules();
}

